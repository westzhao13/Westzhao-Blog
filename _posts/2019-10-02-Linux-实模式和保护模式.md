#Linux-实模式和保护模式

##实模式
###那究竟实模式是什么呢？
	在计算机上面，实模式存在的时间非常之短，所以一般我们是感觉不到它的存在的。CPU复位（reset）或加电（power on）的时候就是以实模式启动，在这个时候处理器以实模式工作，不能实现权限分级，也不能访问20位以上的地址线，也就是只能访问1M内存。之后一般就加载操作系统模块，进入保护模式。
	
	处理器8086 有 20 根地址线（不清楚8086的童鞋，可以自行百度，这可处理器非常有名，资料也很多），可以寻址 1MB 内存。但是，它内部的寄存器16 位的，无法在程序中访问整个 1MB 内存。所以，它也是第一款支持内存分段模型的处理器。还有， 8086 处理器只有一种工作模式，即实模式。当然，在那时，还没有实模式这一说。
	
	由于 8086 处理器的成功，推动着 Intel 公司不断地研发更新的处理器， 32 位的时代就这样到来了。尽管 8086 是 16 位的处理器，但它也是 32位架构内的一部分。原因在于， 32 位的处理器架构是从 8086 那里发展来的，是基于 8086 的，具有延续性和兼容性。
	
	32位处理器有自己的 32 位工作模式。在本系列文章中，保护模式其实就是32位模式。在这种模式下，可以完全、充分地发挥处理器的性能。同时，在这种模式下，处理器可以使用它全部的 32根地址线，能够访问4GB 内存。

###实模式的寻址方式与工作机理
	其实，8086的段寄存器和IP寄存器都是16位的，如果按照原先的方式，把段寄存器的内容和偏移地址直接相加来形成物理地址的话，也只能得到 16 位的物理地址。麻烦的是，8086却提供了20根地址线。换句话说，它提供的是20位的物理地址。
	
	提供 20 位地址线的原因很简单， 16 位的物理地址只能访问 64KB 的内存，地址范围是0000H～FFFFH，共 65536 个字节。这样的容量，即使是在那个年代， 也显得捉襟见衬。
	
	所以，65536个字节就是64KB，而 20 位的物理地址则可以访问多达1MB的内存，地址范围从 00000H到FFFFFH。问题是，16 位的段地址和 16 位的偏移地址相加，只能形成 16 位的物理地址，怎么得到这 20位的物理地址呢？
	
	**为了解决这个问题，8086 处理器在形成物理地址时，先将段寄存器的内容左移 4 位（相当于乘以十六进制的10，或者十进制的 16），形成 20 位的段地址，然后再同16位的偏移地址相加，得到20位的物理地址。比如，对于逻辑地址 F000H:052DH，处理器在形成物理地址时，将段地址F000H左移 4 位，变成 F0000H，再加上偏移地址052DH，就形成了20位的物理地址 F052DH。**
	
	这样，因为段寄存器是16位的，在段不重叠的情况下，最多可以将1MB的内存分成65536个段，段地址分别是0000H、0001H、0002H、0003H，……，一直到FFFFH。
	一个地址有段和偏移两部分组成，物理地址的计算公式为：
	物理地址（physicaladdress）=段值（segment） * 16 + 偏移（offset）
	
	其中，segment和offset都是16位的。
	在这种模式下，系统计算实际地址的时候是按照对1M求模的方式进行的，这种技术被称为wrap-around。也就是说，当程序员给出超过1M（100000H-10FFEFH）的地址时，因为逻辑上正常，系统并不认为其访问越界而产生异常，而是自动从0开始计算。

##保护模式
###相比于实模式的优点
	实模式下，用户可以操作整个物理地址空间，这样就加大了非法操作的风险，会导致系统崩溃。
	而在保护模式下，引入了分段的方法，保护了地址空间。
###实现原理
	保护模式：段+偏移，这里的段并不是实模式中的段（实模式下，段值还是可以看作是地址的一部分，比如段值为xxxxh表示以xxxx0h开始的一段内存），而是一个索引，这个索引指向的是一个数据结构（GDT 全局描述符，也可能是LDT）
	
	在实模式下，段地址并非真实的物理地址，在计算物理地址时，还要左移 4 位（乘以 16）。和实模式不同，在 32 位保护模式下，段地址是 32 位的线性地址，如果未开启分页功能，该线性地址就是物理地址。